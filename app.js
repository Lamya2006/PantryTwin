// --- Data Structures (Now used for client-side state, Cart, and local recipes) ---
// Fetched data from Flask will be stored here:
let fetchedPantry = []; 
let currentCart = []; // Still local as there is no API endpoint for the Cart
let fetchedGroceryList = []; // Stores the Smart List generated by Flask

// Local database for simulated features (Recipe Analyzer, Discounts)
let recipeDB = [
    { name: 'Tomato Pasta', ingredients: ['Tomato', 'Onion', 'Pasta', 'Basil', 'Cheese'], carbonValue: 8.5 },
    { name: 'Peanut Chicken', ingredients: ['Chicken', 'Peanut Butter', 'Soy Sauce', 'Rice'], carbonValue: 9.2 }
];
let appState = {
    ecoPoints: 0,
    familySize: 1,
    allergies: ["lactose", "peanuts"], // Defaulting to server's allergies for consistency
};

// Mock Discount Data (unchanged, as there's no API for this)
const DISCOUNT_DATA = [
    { item: 'Pasta', deal: '$0.99/box - Limit 5', store: 'ShopRite', relevance: 'high' },
    { item: 'Chicken Breast', deal: '$2.99/lb', store: 'ShopRite', relevance: 'medium' },
    { item: 'Milk', deal: 'Buy 1 Get 1 Free', store: 'ShopRite', relevance: 'high' },
    { item: 'Bread', deal: '50% Off Select Loaves', store: 'ShopRite', relevance: 'medium' },
    { item: 'Cereal', deal: 'Any Box $3.00', store: 'ShopRite', relevance: 'low' }
];

const HIGH_CARBON_THRESHOLD = 10.0; 
let missingItemsGlobal = []; // Used by the Waste Minimizer Modal

// --- API FETCHERS ---

/** Fetches pantry data from the Flask API and stores it locally. */
async function fetchPantryData() {
    try {
        const response = await fetch('/api/pantry');
        if (!response.ok) throw new Error('Failed to fetch pantry data');
        fetchedPantry = await response.json();
    } catch (error) {
        console.error("Error fetching pantry:", error);
    }
}

/** Fetches the Smart Grocery List from the Flask API and updates the view. */
async function fetchAndRenderSmartList() {
    const listOutputEl = document.getElementById('grocery-list-output');
    try {
        const response = await fetch('/api/grocery_list');
        if (!response.ok) throw new Error('Failed to fetch smart list');
        fetchedGroceryList = await response.json();

        if (fetchedGroceryList.length > 0) {
             const listHTML = fetchedGroceryList.map(item => 
                 `<div class="list-item"><span>${item}</span></div>`
             ).join('');
             listOutputEl.innerHTML = `<strong>Smart Shopping List Suggestions:</strong><div style="margin-top: 10px;">${listHTML}</div>`;
        } else {
             listOutputEl.innerHTML = 'No automatic shopping list suggestions or user-added items yet.';
        }
    } catch (error) {
        console.error("Error fetching smart list:", error);
    }
}


// --- CORE RENDERING ---

function formatDate(dateString) {
    if (!dateString) return 'N/A';
    try {
        const date = new Date(dateString);
        // Date objects need to be offset by a day if they are simple 'YYYY-MM-DD' strings 
        // to avoid timezone issues. Adding a small time offset helps.
        date.setMinutes(date.getMinutes() + date.getTimezoneOffset());
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    } catch (e) {
        return 'Invalid Date';
    }
}

/** Renders all lists after fetching data. */
async function renderLists() {
    // 1. Fetch the data from the server
    await fetchPantryData();
    await fetchAndRenderSmartList();

    const pantryListEl = document.getElementById('pantry-list');
    const cartListEl = document.getElementById('cart-list');

    // 2. Render Pantry (using fetchedPantry)
    pantryListEl.innerHTML = fetchedPantry.map(item => `
        <div class="list-item">
            <span>${item.name}</span>
            <small style="color: ${item.is_alert ? 'red' : item.is_expired ? 'gray' : 'green'};">
                ${item.is_expired ? 'EXPIRED!' : item.is_alert ? `ALERT: ${item.days_left} days left` : `OK (${item.days_left} days)`}
            </small>
        </div>
    `).join('');

    // 3. Render Cart (using local currentCart)
    cartListEl.innerHTML = currentCart.map(item => `
        <div class="list-item">
            <span>${item.name}</span>
        </div>
    `).join('');
    
    // Final checks
    checkAllergyAlert();
}


// --- USER SETUP & ALLERGY LOGIC ---

function setAlerts() {
    const size = parseInt(document.getElementById('family-size').value);
    const allergiesStr = document.getElementById('allergy-input').value;
    
    appState.familySize = size > 0 ? size : 1;
    appState.allergies = allergiesStr.split(',').map(a => a.trim().toLowerCase()).filter(a => a.length > 0);
    
    checkAllergyAlert();
    alert(`Setup saved: ${appState.familySize} members. Alerts for: ${appState.allergies.join(', ') || 'None'}`);
}

function checkAllergyAlert() {
    const banner = document.getElementById('allergy-alert-banner');
    if (appState.allergies.length === 0) {
        banner.style.display = 'none';
        return;
    }

    const currentCartNames = currentCart.map(i => i.name.toLowerCase());
    
    // Check if any cart item contains an allergy keyword or is an item flagged in the fetched pantry
    const foundAllergy = appState.allergies.some(allergy => 
        currentCartNames.some(item => item.includes(allergy))
    );

    if (foundAllergy) {
        banner.style.display = 'block';
    } else {
        banner.style.display = 'none';
    }
}

// --- ECO POINTS LOGIC ---

function updatePoints(amount) {
    appState.ecoPoints += amount;
    document.getElementById('points-value').innerText = appState.ecoPoints;
}

// --- DISCOUNT ANALYZER LOGIC (Local) ---

function checkWeeklyDiscounts() {
    const outputEl = document.getElementById('discount-output');
    // NOTE: This uses local cart data and the fetched pantry data
    const cartNames = currentCart.map(i => i.name.toLowerCase());
    const pantryNames = fetchedPantry.map(i => i.name.toLowerCase());
    
    let dealsHTML = '';
    let foundDeals = 0;

    DISCOUNT_DATA.forEach(deal => {
        const dealItemLower = deal.item.toLowerCase();
        let highlight = '';
        
        if (cartNames.includes(dealItemLower)) {
            highlight = 'üõí **ITEM IN CART!**';
        }
        else if (!pantryNames.includes(dealItemLower) && deal.relevance === 'high') {
            highlight = 'üí° **PANTRY RESTOCK SUGGESTION!**';
        }
        
        if (highlight) {
            dealsHTML += `
                <div class="discount-item">
                    <strong>${deal.item}</strong>: ${deal.deal}
                    <div style="font-size: 0.9em; color: #cc6600;">${highlight}</div>
                </div>`;
            foundDeals++;
        }
    });

    if (foundDeals > 0) {
        outputEl.innerHTML = `**${foundDeals} Personalized Deals at ShopRite:**<br><br>` + dealsHTML;
    } else {
        outputEl.innerHTML = 'No critical deals found for items currently in your cart or missing from your pantry inventory.';
    }
}


// --- GROCERY LIST GENERATION LOGIC (Local recipe search) ---

function generateGroceryList() {
    const recipeNameInput = document.getElementById('list-recipe-name');
    const recipeName = recipeNameInput.value.trim();
    const outputEl = document.getElementById('grocery-list-output');

    const recipe = recipeDB.find(r => r.name.toLowerCase() === recipeName.toLowerCase());

    if (!recipe) {
        outputEl.innerHTML = `Recipe "<strong>${recipeName}</strong>" not found. Please scan and save it first.`;
        return;
    }

    outputEl.innerHTML = `<strong>List for ${recipe.name}:</strong>`;
    
    const pantryNames = fetchedPantry.map(i => i.name.toLowerCase());
    
    const listHTML = recipe.ingredients.map(ing => {
        const status = pantryNames.includes(ing.toLowerCase()) ? '‚úÖ (In Pantry)' : 'üõí (Needs Buying)';
        const color = pantryNames.includes(ing.toLowerCase()) ? 'green' : 'blue';
        return `<div class="list-item"><span>${ing}</span><small style="color: ${color};">${status}</small></div>`;
    }).join('');

    outputEl.innerHTML += `<div style="margin-top: 10px;">${listHTML}</div>`;
    recipeNameInput.value = '';
}


// --- RECIPE SCANNER/LEARNING LOGIC (Local) ---

function simulateRecipeScan() {
    const imageInput = document.getElementById('recipe-image-input');
    const carbonOutputEl = document.getElementById('carbon-output');
    const learningArea = document.getElementById('learning-input-area');

    if (!imageInput.files || imageInput.files.length === 0) {
        carbonOutputEl.innerHTML = '‚ö†Ô∏è <strong>ERROR:</strong> Please select a picture first.';
        carbonOutputEl.className = 'high-carbon';
        return;
    }

    carbonOutputEl.innerHTML = 'Scanning image... Simulating OCR process...';
    carbonOutputEl.className = '';
    
    setTimeout(() => {
        const fileName = imageInput.files[0].name;
        const learnedRecipe = recipeDB.find(r => fileName.toLowerCase().includes(r.name.toLowerCase().replace(/\s/g, '')));

        if (learnedRecipe) {
            const totalFootprint = learnedRecipe.carbonValue;
            let message = `üçΩÔ∏è <strong>SUCCESS!</strong> Recipe '${learnedRecipe.name}' recognized. Footprint: <strong>${totalFootprint.toFixed(1)} kg CO‚ÇÇe</strong>`;
            
            if (totalFootprint >= HIGH_CARBON_THRESHOLD) {
                message += '<br>üî• <strong>HIGH IMPACT!</strong> Consider a low-carbon substitute.';
                carbonOutputEl.className = 'high-carbon';
            } else {
                message += '<br>üå± <strong>LOW IMPACT!</strong> You earned 5 Eco-Points!';
                carbonOutputEl.className = '';
                updatePoints(5);
            }
            
            carbonOutputEl.innerHTML = message;
            learningArea.style.display = 'none';

        } else {
            carbonOutputEl.innerHTML = 'ü§î <strong>NEW RECIPE DETECTED!</strong> I need your help to learn the name, ingredients, and carbon value (e.g., 2.5) to analyze it for the future.';
            carbonOutputEl.className = '';
            learningArea.style.display = 'block';
        }
    }, 1500); 
}

function saveLearnedRecipe() {
    const name = document.getElementById('simulated-recipe-name').value.trim();
    const ingredientsStr = document.getElementById('simulated-ingredients').value.trim();
    const carbonStr = document.getElementById('simulated-carbon').value.trim();
    const carbonValue = parseFloat(carbonStr);

    if (name && ingredientsStr && !isNaN(carbonValue)) {
        const ingredients = ingredientsStr.split(',').map(i => i.trim());
        
        recipeDB.push({ name: name, ingredients: ingredients, carbonValue: carbonValue });

        document.getElementById('carbon-output').innerHTML = `‚úÖ <strong>Learned!</strong> Recipe '${name}' saved with footprint ${carbonValue.toFixed(1)} kg CO‚ÇÇe.`;
        document.getElementById('learning-input-area').style.display = 'none';
        document.getElementById('simulated-recipe-name').value = '';
        document.getElementById('simulated-ingredients').value = '';
        document.getElementById('simulated-carbon').value = '';
        renderLists(); 

    } else {
        alert('Please fill out all learning fields correctly.');
    }
}


// --- CHATBOT LOGIC (API Call) ---

function appendMessage(sender, text) {
    const chatBox = document.getElementById('chat-box');
    const msgDiv = document.createElement('div');
    msgDiv.className = `message ${sender === 'bot' ? 'bot-msg' : 'user-msg'}`;
    // Basic formatting for bot responses
    msgDiv.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); 
    chatBox.appendChild(msgDiv);
    chatBox.scrollTop = chatBox.scrollHeight; 
}

function toggleChatWindow() {
    const windowEl = document.getElementById('chat-window');
    const buttonEl = document.getElementById('chat-toggle-btn');
    const isHidden = windowEl.style.display === 'none' || windowEl.style.display === '';

    windowEl.style.display = isHidden ? 'flex' : 'none';
    buttonEl.classList.toggle('active', isHidden);
    
    if (isHidden) {
        if (document.querySelectorAll('.message').length === 0) {
            appendMessage('bot', `Hi! I'm your **Pantry Twin** Assistant. Family size is ${appState.familySize}. Ask me about what you can cook!`);
        }
    }
}

/** The core function that sends the user message to the Flask API. */
async function processUserMessage() {
    const inputEl = document.getElementById('chat-input');
    const userText = inputEl.value.trim();
    
    if (userText === '') return;

    appendMessage('user', inputEl.value);
    inputEl.value = '';

    try {
        const response = await fetch('/api/converse', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ question: userText })
        });

        const result = await response.json();

        if (result.status === 'action_success' && result.action === 'ADD_TO_LIST') {
            // AI tool use detected: item added to list on the backend
            const botResponse = result.message || `Got it! Added **${result.item}** to your list.`;
            appendMessage('bot', botResponse);
            await fetchAndRenderSmartList(); // Update the displayed smart list
        } else if (result.status === 'success') {
            // Conversational response from Gemini
            setTimeout(() => appendMessage('bot', result.response), 500);
        } else {
            // Error handling
            setTimeout(() => appendMessage('bot', `An error occurred: ${result.message}`), 500);
        }

    } catch (e) {
        console.error("Chatbot API Error:", e);
        setTimeout(() => appendMessage('bot', "Sorry, I can't connect to the server right now."), 500);
    }
}


// --- LOCAL ADD/REMOVE ITEM LOGIC ---

// Since there is no Flask API to ADD items, we are simulating a local push 
// and then triggering a refresh of the views.
document.getElementById('add-pantry-btn').addEventListener('click', () => {
    alert("NOTE: Adding to Pantry is currently a placeholder function in the front-end.");
    // This function should eventually call a Flask /api/add_pantry endpoint.
    // For now, it only refreshes the lists which are currently read-only from the API.
    renderLists(); 
});

document.getElementById('add-cart-btn').addEventListener('click', () => {
    const nameInput = document.getElementById('cart-item-name');
    const name = nameInput.value.trim();

    if (name) {
        currentCart.push({ name });
        nameInput.value = '';
        renderLists(); // Renders the local cart data
    } else {
        alert('Please enter an item name for the cart.');
    }
});

document.getElementById('chat-input').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        processUserMessage();
    }
});


// --- WASTE MINIMIZER CORE LOGIC (Local) ---

function triggerWasteMinimizer() {
    checkAllergyAlert();

    // Use the fetched pantry data for the check
    const atRiskItems = fetchedPantry.filter(item => item.is_alert);
    
    if (atRiskItems.length === 0) {
        alert("No items expiring soon! You're good to go.");
        return;
    }

    const atRiskNames = atRiskItems.map(item => item.name);
    // Combine fetched pantry with local cart for 'current items'
    const allItems = [...fetchedPantry.map(i => i.name), ...currentCart.map(i => i.name)];
    const missingItemsSet = new Set();
    let prioritizedRecipes = [];

    recipeDB.forEach(recipe => {
        const usesAtRisk = recipe.ingredients.some(ing => atRiskNames.includes(ing));
        if (usesAtRisk) {
            recipe.ingredients
                .filter(ing => !allItems.includes(ing))
                .forEach(ing => missingItemsSet.add(ing));

            let atRiskUsedCount = recipe.ingredients.filter(ing => atRiskNames.includes(ing)).length;
            let missingCount = recipe.ingredients.filter(ing => !allItems.includes(ing)).length;

            let usageScore = atRiskUsedCount * 5; 
            let score = usageScore - missingCount;
            
            prioritizedRecipes.push({ 
                ...recipe, 
                score: score, 
                missing: missingCount,
                atRiskUsed: recipe.ingredients.filter(ing => atRiskNames.includes(ing)).join(', ')
            });
        }
    });

    prioritizedRecipes.sort((a, b) => b.score - a.score);
    const top3Recipes = prioritizedRecipes.slice(0, 3);
    
    document.getElementById('at-risk-display').innerHTML = atRiskNames
        .map(name => `<span class="item-tag">${name}</span>`)
        .join('');

    let suggestionsHTML = '';
    if (top3Recipes.length > 0) {
        suggestionsHTML = top3Recipes.map(recipe => {
            const carbonMsg = recipe.carbonValue ? ` (Footprint: ${recipe.carbonValue.toFixed(1)} kg CO‚ÇÇe)` : '';
            return `
                <div class="recipe-suggestion">
                    <strong>Suggested Recipe: ${recipe.name}</strong>
                    <p style="font-size: 0.9em; margin: 5px 0 0;">
                        Uses: <strong>${recipe.atRiskUsed}</strong> ${carbonMsg}
                    </p>
                </div>`;
        }).join('');
        document.getElementById('recipe-suggestions-container').innerHTML = suggestionsHTML;
    } else {
         document.getElementById('recipe-suggestions-container').innerHTML = '<p>No great recipe matches found for the expiring items and your current cart.</p>';
    }

    missingItemsGlobal = Array.from(missingItemsSet);
    showModal();
}

function showModal() {
    document.getElementById('waste-alert-modal').style.display = 'flex';
}

function hideModal() {
    document.getElementById('waste-alert-modal').style.display = 'none';
}

function addMissingItemsToCart() {
    if (missingItemsGlobal.length > 0) {
        missingItemsGlobal.forEach(item => {
            if (!currentCart.find(i => i.name.toLowerCase() === item.toLowerCase())) {
                currentCart.push({ name: item });
            }
        });
        alert(`Added: ${missingItemsGlobal.join(', ')} to your cart!`);
        renderLists();
        hideModal();
    } else {
         alert('No missing items to add!');
         hideModal();
    }
}

// --- INITIALIZATION ---

window.onload = async () => {
    // CRITICAL: Ensure the HTML links are fixed (using {{ url_for(...) }}) 
    // before running the app.
    
    // First, set up event listener for the chat button, as it's not a simple onclick
    document.getElementById('chat-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            processUserMessage();
        }
    });
    
    // Then, fetch data and render the initial view
    await renderLists(); 
    setAlerts();
};